/*************/
/* Based on a template by Oren Ish-Shalom */
/*************/


/*************/
/* IMPORTS */
/*************/

import java_cup.runtime.*;
import ast.*;
import java.util.List;
import java.util.LinkedList;

parser code
{:
	public Lexer lexer;

	public Parser(Lexer lexer)
	{
		super(lexer);
		this.lexer = lexer;
	}

	// Override default error reporting in parser
	public void report_error(String message, Object info)
	{
	    System.err.print("Syntax error at line " + lexer.getLine() + " of input. Parser\n");
		System.exit(1);
	}
:}

/************************/
/* CUSTOMIZE CUP PARSER */
/************************/
scan with
{:
	Symbol s;
    try {
	s = lexer.next_token();
	System.out.print(s.sym);
	System.out.print("[");
	System.out.print(lexer.getLine());
	System.out.print(":");
	System.out.print(lexer.getCharPos());
	System.out.print("] ");
	System.out.print(sym.terminalNames[s.sym]);
	if (s.value != null)
	{
	    System.out.print("( ");
	    System.out.print(s.value);
	    System.out.print(" )");
	}
	System.out.print("\n");
	return s;
     } catch (java.lang.Error e) {
         System.err.print("Syntax error at line " + lexer.getLine() + " of input. Lexer\n");
         System.exit(1);
         return null;
     }
:};

/*************/
/* TERMINALS */
/*************/
terminal PUBLIC;
terminal STATIC;
terminal CLASS;
terminal EXTENDS;
terminal PLUS;
terminal MINUS;
terminal MULT;
terminal DIV;
terminal ASS;
terminal NOT;
terminal WHILE;
terminal IF;
terminal ELSE;
terminal TRUE;
terminal FALSE;
terminal LT;
terminal AND;
terminal THIS;
terminal COMMA;
terminal LPAREN;
terminal RPAREN;
terminal LBR;
terminal RBR;
terminal LSQBR;
terminal RSQBR;
terminal SEMICOLON;
terminal RET;
terminal STRINGARGS;
terminal SYSTEM;
terminal int INTEGER;
terminal String ID;

/*****************/
/* NON TERMINALS */
/*****************/
// TODO EX4 - fill with non terminals
// E.g
// non terminal Expr expr;

non terminal Program prog;
non terminal Expr expr;
non terminal MainClass mainClass;
non terminal ClassDecl classDecl;
non terminal LinkedList<ClassDecl> classDecls;
non terminal type;
non terminal Statement stmt;
non terminal LinkedList<Expr> commaExprList;
non terminal Statement mainStatement;

/***********************/
/* OPERATOR PRECEDENCE */
/***********************/
// TODO EX4 - fill with precedence (lowest line has higher precedence)
// E.g
// precedence PLUS, MINUS;
// precedence DIV, MULT;

/************************/
/* INITIAL NON TERMINAL */
/************************/
start with prog;

/********************/
/* PRODUCTION RULES */
/********************/
// TODO EX4 - fill with production rules

prog            ::=       mainClass:mainClass classDecls:classDecls  {: RESULT = new Program(mainClass, classDecls); :}
                        ;

mainClass       ::=       CLASS ID:mainClass LBR PUBLIC STATIC ID:type ID:name LPAREN STRINGARGS ID:argsName RPAREN LBR mainStatement:mainStatement RBR RBR {: RESULT = new MainClass(mainClass, argsName, mainStatement); :}
                        ;

classDecls      ::=       classDecl:classDecl classDecls:classDecls {: classDecls.addFirst(classDecl); RESULT = classDecls; :}
                        | /* empty */           	{: RESULT = new LinkedList<ClassDecl>(); :}
                        ;
classDecl       ::=       CLASS ID:className LBR RBR {: RESULT = new ClassDecl(className, null, null, null); :}
                        ;

mainStatement   ::=      SYSTEM LPAREN expr:expr RPAREN SEMICOLON           	{: RESULT = new SysoutStatement(expr); :}
                        ;

expr            ::=      INTEGER:num {: RESULT = new IntegerLiteralExpr(num); :}
                        ;
